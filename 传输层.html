<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>传输层 - 计算机网络</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="favicon.svg">
        <link rel="shortcut icon" href="favicon.png">
        <link rel="stylesheet" href="css/variables.css">
        <link rel="stylesheet" href="css/general.css">
        <link rel="stylesheet" href="css/chrome.css">
        <link rel="stylesheet" href="css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" href="highlight.css">
        <link rel="stylesheet" href="tomorrow-night.css">
        <link rel="stylesheet" href="ayu-highlight.css">

        <!-- Custom theme stylesheets -->


        <!-- Provide site root to javascript -->
        <script>
            var path_to_root = "";
            var default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? "navy" : "light";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                var theme = localStorage.getItem('mdbook-theme');
                var sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            var theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            var sidebar = null;
            var sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title">计算机网络</h1>

                    <div class="right-buttons">
                        <a href="print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.4/dist/katex.min.css">
<h1 id="传输层"><a class="header" href="#传输层">传输层</a></h1>
<ul>
<li><a href="#%E6%A6%82%E8%BF%B0">概述</a>
<ul>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E4%B8%BB%E8%A6%81%E5%8A%9F%E8%83%BD">传输层的主要功能</a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%8D%8F%E8%AE%AE">传输层协议</a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E7%9A%84%E7%AB%AF%E5%8F%A3">传输层的端口</a></li>
<li><a href="#%E4%BC%A0%E8%BE%93%E5%B1%82%E5%9C%A8%E7%BD%91%E7%BB%9C%E6%A8%A1%E5%9E%8B%E4%B8%AD%E7%9A%84%E4%BD%8D%E7%BD%AE">传输层在网络模型中的位置</a></li>
</ul>
</li>
<li><a href="#%E7%94%A8%E6%88%B7%E6%95%B0%E6%8D%AE%E6%8A%A5%E5%8D%8F%E8%AE%AEudp">用户数据报协议（UDP）</a>
<ul>
<li><a href="#udp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9">UDP 的主要特点</a></li>
<li><a href="#udp-%E6%95%B0%E6%8D%AE%E6%8A%A5%E7%BB%93%E6%9E%84">UDP 数据报结构</a></li>
<li><a href="#udp-%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">UDP 的工作流程</a></li>
<li><a href="#udp-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">UDP 的优缺点</a></li>
<li><a href="#udp-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">UDP 应用场景</a></li>
</ul>
</li>
<li><a href="#%E4%BC%A0%E8%BE%93%E6%8E%A7%E5%88%B6%E5%8D%8F%E8%AE%AEtcp">传输控制协议（TCP）</a>
<ul>
<li><a href="#tcp-%E7%9A%84%E4%B8%BB%E8%A6%81%E7%89%B9%E7%82%B9">TCP 的主要特点</a></li>
<li><a href="#tcp-%E6%95%B0%E6%8D%AE%E6%AE%B5%E7%BB%93%E6%9E%84">TCP 数据段结构</a></li>
<li><a href="#tcp-%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">TCP 的优缺点</a></li>
<li><a href="#tcp-%E5%BA%94%E7%94%A8%E5%9C%BA%E6%99%AF">TCP 应用场景</a></li>
</ul>
</li>
<li><a href="#udp%E5%92%8Ctcp%E7%9A%84%E5%AF%B9%E6%AF%94">UDP和TCP的对比</a></li>
<li><a href="#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">TCP 流量控制</a>
<ul>
<li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E7%9B%AE%E6%A0%87">流量控制的目标</a></li>
<li><a href="#tcp-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%9C%BA%E5%88%B6">TCP 流量控制的工作机制</a></li>
<li><a href="#%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6%E7%9A%84%E4%BC%98%E7%BC%BA%E7%82%B9">流量控制的优缺点</a></li>
<li><a href="#%E4%B8%8E%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E5%8C%BA%E5%88%AB">与拥塞控制的区别</a></li>
<li><a href="#%E9%80%82%E7%94%A8%E5%9C%BA%E6%99%AF">适用场景</a></li>
</ul>
</li>
<li><a href="#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">TCP 拥塞控制</a>
<ul>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E7%9B%AE%E6%A0%87">拥塞控制的目标</a></li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86">拥塞控制的工作原理</a>
<ul>
<li><a href="#1-%E6%85%A2%E5%90%AF%E5%8A%A8slow-start">1. 慢启动（Slow Start）</a></li>
<li><a href="#2-%E6%8B%A5%E5%A1%9E%E9%81%BF%E5%85%8Dcongestion-avoidance">2. 拥塞避免（Congestion Avoidance）</a></li>
<li><a href="#3-%E5%BF%AB%E9%80%9F%E9%87%8D%E4%BC%A0fast-retransmit">3. 快速重传（Fast Retransmit）</a></li>
<li><a href="#4-%E5%BF%AB%E9%80%9F%E6%81%A2%E5%A4%8Dfast-recovery">4. 快速恢复（Fast Recovery）</a></li>
</ul>
</li>
<li><a href="#%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%97%B6%E9%97%B4%E7%9A%84%E9%80%89%E6%8B%A9">超时重传时间的选择</a></li>
<li><a href="#tcp-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E6%95%B4%E4%BD%93%E6%B5%81%E7%A8%8B">TCP 拥塞控制的整体流程</a></li>
<li><a href="#%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6%E7%9A%84%E8%BF%9B%E6%AD%A5%E4%B8%8E%E6%8C%91%E6%88%98">拥塞控制的进步与挑战</a></li>
</ul>
</li>
<li><a href="#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93">TCP 可靠传输</a>
<ul>
<li><a href="#%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%85%B3%E9%94%AE%E6%9C%BA%E5%88%B6">可靠传输的关键机制</a>
<ul>
<li><a href="#1-%E6%95%B0%E6%8D%AE%E5%88%86%E6%AE%B5">1. 数据分段</a></li>
<li><a href="#2-%E5%BA%8F%E5%88%97%E5%8F%B7">2. 序列号</a></li>
<li><a href="#3-%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94ack">3. 确认应答（ACK）</a></li>
<li><a href="#4-%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6">4. 重传机制</a></li>
<li><a href="#5-%E6%A0%A1%E9%AA%8C%E5%92%8C">5. 校验和</a></li>
<li><a href="#6-%E6%B5%81%E9%87%8F%E6%8E%A7%E5%88%B6">6. 流量控制</a></li>
<li><a href="#7-%E6%8B%A5%E5%A1%9E%E6%8E%A7%E5%88%B6">7. 拥塞控制</a></li>
</ul>
</li>
<li><a href="#tcp-%E5%8F%AF%E9%9D%A0%E4%BC%A0%E8%BE%93%E7%9A%84%E5%B7%A5%E4%BD%9C%E6%B5%81%E7%A8%8B">TCP 可靠传输的工作流程</a></li>
<li><a href="#%E5%8F%AF%E9%9D%A0%E6%80%A7%E4%BF%9D%E8%AF%81%E7%9A%84%E6%A1%88%E4%BE%8B">可靠性保证的案例</a></li>
</ul>
</li>
<li><a href="#tcp%E8%BF%90%E8%BE%93%E8%BF%9E%E6%8E%A5%E7%AE%A1%E7%90%86%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B%E5%92%8C%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE">TCP运输连接管理（连接建立和连接释放）</a>
<ul>
<li><a href="#%E8%BF%9E%E6%8E%A5%E5%BB%BA%E7%AB%8B">连接建立</a>
<ul>
<li><a href="#%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4">三次握手的具体步骤</a></li>
</ul>
</li>
<li><a href="#%E8%BF%9E%E6%8E%A5%E9%87%8A%E6%94%BE">连接释放</a>
<ul>
<li><a href="#%E5%9B%9B%E6%AC%A1%E6%8C%A5%E6%89%8B%E7%9A%84%E5%85%B7%E4%BD%93%E6%AD%A5%E9%AA%A4">四次挥手的具体步骤</a></li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="概述"><a class="header" href="#概述">概述</a></h2>
<p><strong>传输层</strong> 是计算机网络体系结构中的一个重要层次，位于网络层之上，应用层之下。传输层的主要任务是为不同主机上的应用程序提供可靠和高效的数据传输服务。它负责数据的分段、重组、流量控制以及错误检测和修正等功能。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131203334.png" alt="" /></p>
<p>传输层在计算机网络中扮演着至关重要的角色，确保了数据在不同主机之间的可靠传输。通过 TCP 和 UDP 等协议，传输层为各种类型的应用提供了必要的支持，以满足不同的网络通信需求。</p>
<h3 id="传输层的主要功能"><a class="header" href="#传输层的主要功能">传输层的主要功能</a></h3>
<ol>
<li>
<p><strong>数据传输控制</strong>：</p>
<ul>
<li>传输层确保端到端的数据传输，确保发送方和接收方之间的数据能够按顺序正确传输。</li>
</ul>
</li>
<li>
<p><strong>可靠性</strong>：</p>
<ul>
<li>通过协议机制提供数据传输的可靠性，确保数据在传输过程中不会丢失，并在需要时进行重传。</li>
</ul>
</li>
<li>
<p><strong>流量控制</strong>：</p>
<ul>
<li>控制数据传输速度，防止发送方发送数据过快，导致接收方缓冲区溢出，从而出现数据丢失。</li>
</ul>
</li>
<li>
<p><strong>拥塞控制</strong>：</p>
<ul>
<li>监控网络状态，并在网络发生拥塞时采取措施减少数据流量，避免使网络进一步拥堵。</li>
</ul>
</li>
<li>
<p><strong>分段与重组</strong>：</p>
<ul>
<li>传输层将应用层传来的数据分段以适应网络的传输要求，并在接收方重组这些数据段。</li>
</ul>
</li>
</ol>
<h3 id="传输层协议"><a class="header" href="#传输层协议">传输层协议</a></h3>
<p>传输层常用的协议主要有两种：<strong>传输控制协议（TCP）</strong> 和 <strong>用户数据报协议（UDP）</strong>。</p>
<ol>
<li>传输控制协议（TCP）</li>
</ol>
<ul>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>面向连接</strong>：在数据传输开始前，TCP 在发送方和接收方之间建立连接。</li>
<li><strong>可靠性</strong>：TCP 通过序列号、确认应答、重传机制等方式确保数据的可靠性。</li>
<li><strong>有序传输</strong>：数据段按顺序到达接收方，如果发生乱序，则通过序列号进行排序。</li>
<li><strong>流量控制</strong>：使用滑动窗口机制调节数据流量。</li>
<li><strong>拥塞控制</strong>：采用慢启动、拥塞避免、快重传和快恢复等算法来避免网络拥塞。</li>
</ul>
</li>
<li>
<p><strong>工作流程</strong>：</p>
<ol>
<li>
<p><strong>连接建立</strong>：通过三次握手（Three-Way Handshake）建立连接：</p>
<ul>
<li>客户端发送 SYN（同步序列编号）请求连接。</li>
<li>服务器响应 SYN-ACK（同步序列编号确认）。</li>
<li>客户端发送 ACK 确认建立连接。</li>
</ul>
</li>
<li>
<p><strong>数据传输</strong>：在连接建立后，双方可以进行数据的交换。</p>
</li>
<li>
<p><strong>连接终止</strong>：通过四次挥手（Four-Way Handshake）终止连接。</p>
</li>
</ol>
</li>
</ul>
<ol start="2">
<li>用户数据报协议（UDP）</li>
</ol>
<ul>
<li>
<p><strong>特点</strong>：</p>
<ul>
<li><strong>无连接</strong>：UDP 在传输数据之前不建立连接，数据包直接发送。</li>
<li><strong>不可靠性</strong>：UDP 不保证数据的可靠接收，没有重传机制，可能会丢失或重复数据。</li>
<li><strong>数据包无序</strong>：数据包的到达顺序不保证在应用层正确。接收方只能根据收到的数据包进行处理。</li>
<li><strong>轻量级</strong>：UDP 协议头部开销小，适合对延迟敏感的应用。</li>
</ul>
</li>
<li>
<p><strong>工作流程</strong>：</p>
<ul>
<li>数据以数据报形式通过 UDP 发送，一旦数据发送完，不需要进行连接的建立和终止。</li>
</ul>
</li>
</ul>
<ol start="3">
<li>选择协议</li>
</ol>
<ul>
<li><strong>TCP</strong> 适合需要高可靠性和有序传输的应用，如文件传输（FTP）、网页浏览（HTTP/HTTPS）、邮件传输（SMTP）等。</li>
<li><strong>UDP</strong> 更适合实时性要求高的应用，如在线游戏、视频会议、直播流媒体等，因其传输延迟低。</li>
</ul>
<h3 id="传输层的端口"><a class="header" href="#传输层的端口">传输层的端口</a></h3>
<p>传输层使用<strong>端口</strong>来区分不同的应用程序。每个运行的应用程序都有一个或多个端口号。端口可以分为：</p>
<ul>
<li><strong>知名端口</strong>（0-1023）：由系统保留给常用服务（如 HTTP: 80, FTP: 21, SMTP: 25 等）。</li>
<li><strong>注册端口</strong>（1024-49151）：供用户和应用程序使用的端口，通常需要申请。</li>
<li><strong>动态/私有端口</strong>（49152-65535）：由客户端应用临时分配，通常在发起连接时使用。</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131203455.png" alt="" /></p>
<h3 id="传输层在网络模型中的位置"><a class="header" href="#传输层在网络模型中的位置">传输层在网络模型中的位置</a></h3>
<p>传输层属于互联网协议套件的四层模型和 OSI 七层模型的第四层。</p>
<ul>
<li>
<p><strong>互联网协议套件（TCP/IP 模型）</strong>：</p>
<ul>
<li>链接层</li>
<li>网络层</li>
<li><strong>传输层</strong></li>
<li>应用层</li>
</ul>
</li>
<li>
<p><strong>OSI 模型</strong>：</p>
<ul>
<li>物理层</li>
<li>数据链路层</li>
<li>网络层</li>
<li><strong>传输层</strong></li>
<li>会话层</li>
<li>表示层</li>
<li>应用层</li>
</ul>
</li>
</ul>
<h2 id="用户数据报协议udp"><a class="header" href="#用户数据报协议udp">用户数据报协议（UDP）</a></h2>
<p><strong>用户数据报协议（UDP, User Datagram Protocol）</strong> 是一种简单的通信协议，属于传输层协议，主要用于在网络上发送数据报文。与传输控制协议（TCP）相比，UDP 提供了更简单的机制和较低的开销，适用于对延迟敏感、但不要求可靠性的应用。</p>
<p>用户数据报协议（UDP）是一种简单且高效的传输协议，适用于对速度敏感的应用。虽然其不可靠性较高，但通过明确的应用场景选择，使得 UDP 成为许多实时和多媒体应用的理想选择。</p>
<h3 id="udp-的主要特点"><a class="header" href="#udp-的主要特点">UDP 的主要特点</a></h3>
<ol>
<li>
<p><strong>无连接性</strong>：</p>
<ul>
<li>UDP 是一种无连接协议，在传输数据之前不需要建立和管理连接。这允许迅速发送数据包，但缺乏连接的控制和管理。</li>
</ul>
</li>
<li>
<p><strong>不可靠性</strong>：</p>
<ul>
<li>UDP 不保证数据包的可靠传输。数据包可能在传输过程中丢失、重复、或者乱序。发送方发送数据后，不会收到任何确认（ACK）响应。</li>
</ul>
</li>
<li>
<p><strong>数据报方式</strong>：</p>
<ul>
<li>UDP 以数据报（Datagram）形式发送数据，每个数据报都是独立的信息单元，UDP 网络层不对数据报的到达状态进行追踪。</li>
</ul>
</li>
<li>
<p><strong>低延迟</strong>：</p>
<ul>
<li>由于 UDP 的简单性和无连接特性，其延迟较低，适合需要快速传输的应用。</li>
</ul>
</li>
<li>
<p><strong>头部开销小</strong>：</p>
<ul>
<li>UDP 的头部相对较小，仅包含 8 字节，较 TCP 的 20 字节头部开销要少，从而提高了传输效率。</li>
</ul>
</li>
</ol>
<h3 id="udp-数据报结构"><a class="header" href="#udp-数据报结构">UDP 数据报结构</a></h3>
<p>UDP 数据报的结构由两个部分组成：头部（Header）和数据（Data）。</p>
<ol>
<li>头部（8 字节）</li>
</ol>
<p>UDP 头部包含以下字段：</p>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>大小（字节）</th><th>描述</th></tr></thead><tbody>
<tr><td>源端口</td><td>2</td><td>发送方的端口号</td></tr>
<tr><td>目的端口</td><td>2</td><td>接收方的端口号</td></tr>
<tr><td>长度</td><td>2</td><td>UDP 数据报的总长度，包括头部和数据部分</td></tr>
<tr><td>校验和</td><td>2</td><td>用于错误检测的数据完整性校验</td></tr>
</tbody></table>
</div>
<ul>
<li>源端口和目的端口用于标识应用程序。</li>
<li>长度字段用于指示UDP数据报的总长度。</li>
<li>校验和用于检查数据在传输过程中是否出现损坏。</li>
</ul>
<ol start="2">
<li>数据</li>
</ol>
<p>数据部分包含要传送的有效负载，可以是任意类型的数据，大小限制在 65,507 字节以内（UDP 数据报的最大长度为 65,535 字节，而头部占用 8 字节）。</p>
<h3 id="udp-的工作流程"><a class="header" href="#udp-的工作流程">UDP 的工作流程</a></h3>
<p>UDP 的工作过程大致包括以下几个步骤：</p>
<ol>
<li>
<p><strong>创建数据报</strong>：</p>
<ul>
<li>源应用程序通过 UDP 在数据链路层上创建一个数据报并指定目标 IP 地址和端口。</li>
</ul>
</li>
<li>
<p><strong>发送数据</strong>：</p>
<ul>
<li>UDP 发送数据时，将数据报封装为 UDP 数据包并通过网络层发送。不进行连接的建立。</li>
</ul>
</li>
<li>
<p><strong>接收数据</strong>：</p>
<ul>
<li>目的主机的 UDP 协议将接收到的数据包传递给对应的应用程序。由于无需确认和重传，即使数据丢失或乱序，UDP 仍会继续发送下一数据包。</li>
</ul>
</li>
</ol>
<h3 id="udp-的优缺点"><a class="header" href="#udp-的优缺点">UDP 的优缺点</a></h3>
<p>优点</p>
<ol>
<li><strong>低延迟</strong>：由于缺少连接建立和管理，UDP 能够实现快速数据传输。</li>
<li><strong>简单高效</strong>：UDP 的头部开销小，适合高效传输小数据块。</li>
<li><strong>适用场景丰富</strong>：适合实时性要求高的应用，如在线游戏、流媒体、VoIP（语音传输）等。</li>
</ol>
<p>缺点</p>
<ol>
<li><strong>不可靠性</strong>：数据可能会丢失、重复或乱序，无法保证数据完整性。</li>
<li><strong>缺乏流量控制与拥塞控制</strong>：UDP 不对传输速度进行调节，可能导致网络拥塞。</li>
<li><strong>错误检测有限</strong>：虽然有校验和字段，但UDP不提供重传机制。</li>
</ol>
<h3 id="udp-应用场景"><a class="header" href="#udp-应用场景">UDP 应用场景</a></h3>
<p>UDP 在许多领域有广泛应用，具体包括：</p>
<ul>
<li><strong>实时应用</strong>：如视频会议、即时消息、在线游戏等，强调当前数据的快速传输，即使丢失少量数据也在所不惜。</li>
<li><strong>流媒体应用</strong>：如音频和视频流传输，在不保证顺序的情况下，允许通过数据包的连续传输实现流畅播放。</li>
<li><strong>广播和组播</strong>：UDP 支持广播（向网络中的所有主机发送）和组播（向特定的一组主机发送），常用于网络服务发现和在线直播传输。</li>
</ul>
<h2 id="传输控制协议tcp"><a class="header" href="#传输控制协议tcp">传输控制协议（TCP）</a></h2>
<p><strong>传输控制协议（TCP，Transmission Control Protocol）</strong> 是一种面向连接的传输层协议，主要用于提供可靠的数据传输服务。TCP 被广泛应用于 Internet 的各种应用，如网络浏览（HTTP/HTTPS）、文件传输（FTP）和电子邮件（SMTP）等。它能确保数据的正确性、顺序、完整性并控制数据的流量。</p>
<p>传输控制协议（TCP）是确保网络上数据可靠传输的基本协议，它为应用程序间提供了一种强有力的机制。在需要高可靠性和顺序性的系统中，TCP 是不可或缺的。</p>
<h3 id="tcp-的主要特点"><a class="header" href="#tcp-的主要特点">TCP 的主要特点</a></h3>
<ol>
<li>
<p><strong>面向连接</strong>：</p>
<ul>
<li>TCP 在发送数据之前，必须在通信双方之间建立虚拟连接，确保两者之间的可靠性和同步。</li>
</ul>
</li>
<li>
<p><strong>可靠性</strong>：</p>
<ul>
<li>TCP 通过序列号、确认应答（ACK）和重传机制确保数据的可靠传输。每个数据段在发送后都需要确认，未被确认的数据会被重新发送。</li>
</ul>
</li>
<li>
<p><strong>有序传输</strong>：</p>
<ul>
<li>TCP 确保数据包按正确的顺序到达接收方。即使发送方以不同顺序发送数据包，TCP 也能在接收方进行排序。</li>
</ul>
</li>
<li>
<p><strong>流量控制</strong>：</p>
<ul>
<li>TCP 使用滑动窗口机制控制数据流的速度，避免接收方缓冲区溢出，从而确保传输的平稳性。</li>
</ul>
</li>
<li>
<p><strong>拥塞控制</strong>：</p>
<ul>
<li>TCP 能够监控网络的状态，并在网络拥堵时调整数据发送速率，防止进一步的拥塞。</li>
</ul>
</li>
<li>
<p><strong>错误检测与修正</strong>：</p>
<ul>
<li>TCP 对每个数据段使用校验和对数据完整性进行验证，确保传输的数据未被损坏。</li>
</ul>
</li>
</ol>
<h3 id="tcp-数据段结构"><a class="header" href="#tcp-数据段结构">TCP 数据段结构</a></h3>
<p>TCP 数据段由头部和数据部分组成。头部用于控制和标识数据段的特性，数据部分则携带应用层的有效负载。</p>
<ol>
<li>TCP 头部结构</li>
</ol>
<p>TCP 头部最小长度为 20 字节，可以附加选项字段，最大长度可达 60 字节。其主要字段包括：</p>
<div class="table-wrapper"><table><thead><tr><th>字段</th><th>大小（字节）</th><th>描述</th></tr></thead><tbody>
<tr><td>源端口</td><td>2</td><td>发送方的端口号</td></tr>
<tr><td>目的端口</td><td>2</td><td>接收方的端口号</td></tr>
<tr><td>序列号</td><td>4</td><td>确定数据段的顺序，用于数据的重新组装</td></tr>
<tr><td>确认号</td><td>4</td><td>下一个期望接收的数据段的序列号</td></tr>
<tr><td>头部长度</td><td>4</td><td>TCP 头部长度</td></tr>
<tr><td>标志位</td><td>6</td><td>控制连接和传输的各种标志（如 SYN、ACK、FIN 等）</td></tr>
<tr><td>窗口大小</td><td>2</td><td>用于流量控制，表示接收方可接收的字节数</td></tr>
<tr><td>校验和</td><td>2</td><td>用于错误检测的校验和</td></tr>
<tr><td>紧急指针</td><td>2</td><td>如果设置了紧急标志，则指示紧急数据的字节数</td></tr>
<tr><td>选项</td><td>可变</td><td>包含可选参数（如最大报文段长度）</td></tr>
<tr><td>数据</td><td>可变</td><td>实际传输的数据</td></tr>
</tbody></table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131211159.png" alt="" /></p>
<ol start="2">
<li>TCP 数据的传输流程</li>
</ol>
<p>TCP 数据传输的流程主要包括以下几个步骤：</p>
<ol>
<li>
<p><strong>连接建立</strong>：</p>
<ul>
<li>使用 <strong>三次握手</strong>（Three-Way Handshake）协议建立连接：
<ul>
<li><strong>第一步</strong>：客户端发送一个 SYN（同步序列编号）包到服务器，请求建立连接。</li>
<li><strong>第二步</strong>：服务器响应一个 SYN-ACK（同步序列编号确认）包，确认连接请求。</li>
<li><strong>第三步</strong>：客户端再发送一个 ACK（确认）包，完成连接建立。</li>
</ul>
</li>
</ul>
</li>
<li>
<p><strong>数据传输</strong>：</p>
<ul>
<li>连接建立后，数据开始顺序传输。发送方通过序列号将数据段分配编号，而接受方通过确认号告知发送方已收到的数据。</li>
</ul>
</li>
<li>
<p><strong>连接终止</strong>：</p>
<ul>
<li>使用 <strong>四次挥手</strong>（Four-Way Handshake）协议终止连接：
<ul>
<li><strong>第一步</strong>：主动关闭连接的一方发送一个 FIN（终止）包。</li>
<li><strong>第二步</strong>：接收方确认该 FIN 包，发送 ACK。</li>
<li><strong>第三步</strong>：接收方发送一个 FIN 包，表示也要关闭连接。</li>
<li><strong>第四步</strong>：主动关闭的一方确认 FIN，完成连接终止。</li>
</ul>
</li>
</ul>
</li>
</ol>
<h3 id="tcp-的优缺点"><a class="header" href="#tcp-的优缺点">TCP 的优缺点</a></h3>
<p>优点</p>
<ol>
<li><strong>可靠性</strong>：确保数据可靠性和完整性，通过重传机制处理丢失的数据。</li>
<li><strong>顺序控制</strong>：能将数据按发送顺序接收并恢复。</li>
<li><strong>流量控制与拥塞控制</strong>：有效管理网络流量，避免拥塞。</li>
</ol>
<p>缺点</p>
<ol>
<li><strong>延迟</strong>：由于建立连接和确认机制，引入了一定的延迟。</li>
<li><strong>开销较大</strong>：相比于 UDP，TCP 的头部较大，具有更高的开销。</li>
<li><strong>复杂性</strong>：管理连接状态、流量及拥塞控制的实现较复杂。</li>
</ol>
<h3 id="tcp-应用场景"><a class="header" href="#tcp-应用场景">TCP 应用场景</a></h3>
<p>TCP 被广泛应用于各种需要可靠传输的场景，包括但不限于：</p>
<ul>
<li><strong>Web 浏览</strong>：HTTP/HTTPS 协议通过 TCP 进行数据传输，确保网页的完整和正确加载。</li>
<li><strong>文件传输</strong>：FTP 协议通过 TCP 传输文件，保证数据的可靠性和顺序。</li>
<li><strong>电子邮件</strong>：SMTP、POP3 和 IMAP 协议依赖于 TCP 进行邮件的发送与接收。</li>
</ul>
<h2 id="udp和tcp的对比"><a class="header" href="#udp和tcp的对比">UDP和TCP的对比</a></h2>
<div class="table-wrapper"><table><thead><tr><th>特性</th><th>TCP</th><th>UDP</th></tr></thead><tbody>
<tr><td>连接方式</td><td>面向连接（三次握手）</td><td>无连接</td></tr>
<tr><td>可靠性</td><td>可靠（重传、确认）</td><td>不可靠（无重传、确认机制）</td></tr>
<tr><td>数据顺序</td><td>保证顺序</td><td>不保证顺序</td></tr>
<tr><td>开销</td><td>较大（头部20-60字节）</td><td>较小（头部8字节）</td></tr>
<tr><td>适用场景</td><td>Web、文件传输、电子邮件等</td><td>在线游戏、视频流、语音传输等</td></tr>
</tbody></table>
</div>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131203552.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131203613.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131203629.png" alt="" /></p>
<p>TCP（传输控制协议）和UDP（用户数据报协议）是两种在互联网中广泛使用的传输层协议，各自适用于不同的应用场景。以下是三种使用它们的协议及其特点：</p>
<p>使用 TCP 的协议</p>
<ol>
<li>
<p><strong>HTTP/HTTPS（超文本传输协议）</strong></p>
<ul>
<li><strong>特点</strong>：HTTP/HTTPS 是用于网页浏览的协议，基于请求-响应模型。它需要可靠的数据传输，确保请求和响应的完整性与顺序，因此使用 TCP。</li>
<li><strong>使用原因</strong>：网页内容往往需要完整传输，任何丢失或错误都会影响用户体验。</li>
</ul>
</li>
<li>
<p><strong>FTP（文件传输协议）</strong></p>
<ul>
<li><strong>特点</strong>：FTP 用于在网络之间传输文件，支持用户登录、文件上传和下载。它需要确认数据的接收和完整性。</li>
<li><strong>使用原因</strong>：文件传输时，确保所有数据完整无误是至关重要的，TCP 提供了这种可靠性。</li>
</ul>
</li>
<li>
<p><strong>SMTP（简单邮件传输协议）</strong></p>
<ul>
<li><strong>特点</strong>：SMTP 用于发送邮件，它需要保证邮件数据的传输可靠性和顺序。</li>
<li><strong>使用原因</strong>：邮件内容必须完整且按照顺序到达接收者，TCP 适合这种需求。</li>
</ul>
</li>
</ol>
<p>使用 UDP 的协议</p>
<ol>
<li>
<p><strong>DNS（域名系统）</strong></p>
<ul>
<li><strong>特点</strong>：DNS 通过 UDP 解析域名与 IP 地址之间的映射，通常使用较小的数据包。</li>
<li><strong>使用原因</strong>：DNS 查询通常很短，且对速度要求高，丢包后可以重试，不需要像 TCP 那样保证每次都可靠。</li>
</ul>
</li>
<li>
<p><strong>DHCP（动态主机配置协议）</strong></p>
<ul>
<li><strong>特点</strong>：DHCP 用于自动分配 IP 地址。它在网络启动时快速发送请求并接收地址。</li>
<li><strong>使用原因</strong>：速度快且不需要每一个数据包都被确认，UDP 适合这种实时需求。</li>
</ul>
</li>
<li>
<p><strong>实时流媒体协议（RTP）</strong></p>
<ul>
<li><strong>特点</strong>：RTP 用于音频和视频流的实时传输，对延迟敏感，通常在 VoIP 或视频会议中使用。</li>
<li><strong>使用原因</strong>：RTP 更注重速度和实时性，偶尔的数据丢失不会显著影响体验，因此使用 UDP。</li>
</ul>
</li>
</ol>
<p>总结</p>
<ul>
<li><strong>TCP</strong>：提供可靠、顺序的传输，适用于需要完整性和确认的应用，如网页、文件传输、邮件等。</li>
<li><strong>UDP</strong>：提供无连接的快速传输，适用于实时应用和对速度有较高要求但可以容忍丢包的场景，如 DNS、DHCP 和流媒体传输。</li>
</ul>
<h2 id="tcp-流量控制"><a class="header" href="#tcp-流量控制">TCP 流量控制</a></h2>
<p>TCP 流量控制是一个重要机制，用于确保发送方和接收方之间的通信是有效和高效的。它通过调节数据的发送速率，避免接收方的缓冲区溢出，从而确保数据的可靠传输。流量控制主要通过调节 TCP 的<strong>窗口大小</strong>来实现。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131204741.png" alt="" /></p>
<p>TCP 的流量控制通过动态调整窗口大小，确保发送和接收之间的信息流保持平衡，避免拥塞和数据丢失。通过这一机制，TCP 能够在不同的网络条件下高效运行，保持数据传输的可靠性。</p>
<h3 id="流量控制的目标"><a class="header" href="#流量控制的目标">流量控制的目标</a></h3>
<ul>
<li><strong>避免数据丢失</strong>：保护接收方的缓冲区，防止数据溢出。</li>
<li><strong>优化传输效率</strong>：在不导致拥塞的情况下，尽可能利用网络带宽。</li>
<li><strong>增强可靠性</strong>：确保所有数据都能被成功接收，不会因缓冲区的不足而被丢弃。</li>
</ul>
<h3 id="tcp-流量控制的工作机制"><a class="header" href="#tcp-流量控制的工作机制">TCP 流量控制的工作机制</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131204706.png" alt="" /></p>
<p>TCP 的流量控制主要依赖于<strong>滑动窗口</strong>（Sliding Window）机制。以下是这一机制的详细说明：</p>
<ol>
<li>滑动窗口（Sliding Window）机制</li>
</ol>
<ul>
<li><strong>定义</strong>：滑动窗口是一种动态调整的缓冲区的大小，指示发送方可以发送多少字节而无需等待接收方确认。</li>
<li><strong>窗口大小</strong>：窗口大小由接收方的缓冲区的可用空间决定。接收方会在 TCP 头部的窗口大小字段中告知发送方当前的可用窗口大小。</li>
</ul>
<ol start="2">
<li>窗口大小的更新</li>
</ol>
<ul>
<li><strong>初始化</strong>：连接建立后，接收方会告知发送方其缓冲区的大小作为初始的窗口大小。</li>
<li><strong>动态调整</strong>：当接收方处理完一定的数据后，它可以通过发送 ACK 报文来通知发送方更新窗口大小。如果接收方的缓冲区满了，它会将窗口大小设置为 0，通知发送方停止发送更多数据。</li>
<li><strong>例子</strong>：假设接收方的初始窗口大小为 10,000 字节，发送方可以在不等待确认的情况下发送最多 10,000 字节的数据。当接收方处理完数据后，可以将窗口大小更新为 5,000 字节。如果接收方的缓冲区为空，又可以上调窗口大小为 8,000 字节。</li>
</ul>
<ol start="3">
<li>自动调整过程</li>
</ol>
<ul>
<li><strong>流量控制的循环</strong>：
<ol>
<li>当接收方缓冲区有更多空间时，它会发送窗口更新消息，允许发送方继续发送数据。</li>
<li>当接收方的缓冲区接近满负荷时，会将窗口大小设置为 0，指示发送方暂时停止发送数据。</li>
<li>发送方随后开始监控窗口更新，并在接收到新的窗口大小后继续发送数据。</li>
</ol>
</li>
</ul>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131204815.png" alt="" /></p>
<h3 id="流量控制的优缺点"><a class="header" href="#流量控制的优缺点">流量控制的优缺点</a></h3>
<p>优点</p>
<ol>
<li><strong>保护接收方</strong>：避免由于接收方处理能力不足而导致的数据丢失和网络拥塞。</li>
<li><strong>灵活性</strong>：窗口大小的动态调整能够根据不同的网络条件优化数据传输。</li>
<li><strong>提升可靠性</strong>：能够确保所有数据在传输过程中保持完整与有序。</li>
</ol>
<p>缺点</p>
<ol>
<li><strong>延迟增加</strong>：如果接收方的缓冲区设置小，可能导致发送方频繁暂停，影响整体的传输效率。</li>
<li><strong>传输优化复杂性</strong>：在高带宽延迟的条件下，流量控制可能无法充分利用带宽（如 TCP 的慢启动机制）。</li>
<li><strong>额外的开销</strong>：流量控制需要额外的控制报文，可能增加网络流量。</li>
</ol>
<h3 id="与拥塞控制的区别"><a class="header" href="#与拥塞控制的区别">与拥塞控制的区别</a></h3>
<ul>
<li><strong>流量控制</strong>：主要关注接收方的处理能力，确保不会因接收方缓冲区不足而丢失数据。</li>
<li><strong>拥塞控制</strong>：关注整个网络的状态，确保网络资源的合理使用，防止避免带宽过载和数据包丢失。</li>
</ul>
<h3 id="适用场景"><a class="header" href="#适用场景">适用场景</a></h3>
<p>TCP 流量控制适用于多种场景，尤其在以下情况下效果显著：</p>
<ul>
<li><strong>文件传输</strong>：如 FTP 协议，确保文件在传输过程中不会因为接收方的处理能力不足而被丢失。</li>
<li><strong>实时应用</strong>：如视频流和 VoIP 通信，能够动态调整流量以适应网络状况。</li>
</ul>
<h2 id="tcp-拥塞控制"><a class="header" href="#tcp-拥塞控制">TCP 拥塞控制</a></h2>
<p>TCP 拥塞控制是确保网络稳定性和高效性的重要机制。它通过监控网络状态，调整数据传输速率，从而避免引发拥塞，确保网络资源的合理分配。拥塞控制是通过控制发送数据的速率和数量来完成的，以避免网络在传输时过载。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131204853.png" alt="" /></p>
<p>TCP 拥塞控制为解决网络拥塞问题提供了一系列高效的工具，确保了数据可靠和高效地在不同的网络条件下传输。通过不同的模式和算法，TCP 能够动态适应网络的变化，处理数据流量，保证了互联网服务的稳定性和可靠性。</p>
<h3 id="拥塞控制的目标"><a class="header" href="#拥塞控制的目标">拥塞控制的目标</a></h3>
<ul>
<li><strong>避免丢包</strong>：通过控制发送速率，减少数据包在网络中丢失的可能性。</li>
<li><strong>提高网络利用率</strong>：在网络状态良好时，尽可能提高数据传输的效率和速率。</li>
<li><strong>公平性</strong>：确保在同一网络中不同连接之间的流量分配尽量公平，防止某个连接占用过多资源。</li>
</ul>
<h3 id="拥塞控制的工作原理"><a class="header" href="#拥塞控制的工作原理">拥塞控制的工作原理</a></h3>
<p>TCP 的拥塞控制主要依赖于以下四种算法：</p>
<ol>
<li><strong>慢启动（Slow Start）</strong></li>
<li><strong>拥塞避免（Congestion Avoidance）</strong></li>
<li><strong>快速重传（Fast Retransmit）</strong></li>
<li><strong>快速恢复（Fast Recovery）</strong></li>
</ol>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131204936.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131205018.png" alt="" /></p>
<h4 id="1-慢启动slow-start"><a class="header" href="#1-慢启动slow-start">1. 慢启动（Slow Start）</a></h4>
<ul>
<li>
<p><strong>定义</strong>：慢启动是 TCP 拥塞控制的初始阶段，用于避免网络的初始拥塞。在这个阶段，TCP 会以指数方式增加发送窗口（cwnd），逐步测试网络的承载能力。</p>
</li>
<li>
<p><strong>工作机制</strong>：</p>
<ul>
<li>初始化时，cwnd（拥塞窗口）通常设置为 1-2 个最大报文段（MSS）。</li>
<li>每当收到一个确认（ACK），cwnd 就增加 1（每次成功发送一段数据包）。</li>
<li>当收到的 ACK 数量为 cwnd 的值时，cwnd 就加倍，形成指数增长。</li>
</ul>
</li>
<li>
<p><strong>例子</strong>：</p>
<ul>
<li>在每个 RTT（往返时延）内，假设在第一轮发送 1 MSS，确认到达后 cwnd 变为 2 MSS，第二轮发送 2 MSS，再次确认到达后 cwnd 变为 4 MSS，如此类推，直到达到阈值。</li>
</ul>
</li>
</ul>
<h4 id="2-拥塞避免congestion-avoidance"><a class="header" href="#2-拥塞避免congestion-avoidance">2. 拥塞避免（Congestion Avoidance）</a></h4>
<ul>
<li>
<p><strong>定义</strong>：当 cwnd 达到一个预设的阈值（ssthresh, slow start threshold）后，TCP 进入拥塞避免阶段。</p>
</li>
<li>
<p><strong>工作机制</strong>：</p>
<ul>
<li>在这一阶段，cwnd 以线性方式增长。每接收到一个 ACK，只增加 1/cwnd。其增长的速率比慢启动阶段缓慢得多，以避免网络拥堵。</li>
</ul>
</li>
<li>
<p><strong>例子</strong>：</p>
<ul>
<li>如果 cwnd 当前值为 16 MSS，当产生一个新的 ACK 时，cwnd 仅增加 1，使得下一轮发送的数据量较之前增长缓慢。</li>
</ul>
</li>
</ul>
<h4 id="3-快速重传fast-retransmit"><a class="header" href="#3-快速重传fast-retransmit">3. 快速重传（Fast Retransmit）</a></h4>
<ul>
<li>
<p><strong>定义</strong>：此机制用于在数据包丢失时进行快速重传，减少等待超时的时间。</p>
</li>
<li>
<p><strong>工作机制</strong>：</p>
<ul>
<li>当接收方收到乱序的数据包时，会向发送方发送重复的 ACK。连续收到三个相同的 ACK 可以认为是数据包的丢失，此时发送方会立即重传丢失的数据包，而不必等待重传超时。</li>
</ul>
</li>
<li>
<p><strong>优点</strong>：</p>
<ul>
<li>提高了响应速度；比依赖超 time-out 重传效率更高。</li>
</ul>
</li>
</ul>
<h4 id="4-快速恢复fast-recovery"><a class="header" href="#4-快速恢复fast-recovery">4. 快速恢复（Fast Recovery）</a></h4>
<ul>
<li>
<p><strong>定义</strong>：在触发快速重传后，进入快速恢复阶段。用于在丢包发生后先继续传输数据，再逐渐增加 cwnd 以恢复到较高的发送速率。</p>
</li>
<li>
<p><strong>工作机制</strong>：</p>
<ul>
<li>当触发快速重传时，ssthresh 被设置为当前 cwnd 值的一半。</li>
<li>cwnd 在重传后的每次收到 ACK 时增加 1，直至达到 ssthresh，后进入拥塞避免阶段。</li>
</ul>
</li>
</ul>
<h3 id="超时重传时间的选择"><a class="header" href="#超时重传时间的选择">超时重传时间的选择</a></h3>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131205133.png" alt="" /></p>
<h3 id="tcp-拥塞控制的整体流程"><a class="header" href="#tcp-拥塞控制的整体流程">TCP 拥塞控制的整体流程</a></h3>
<ol>
<li>
<p><strong>连接开始</strong>：</p>
<ul>
<li>TCP 在连接时进入慢启动阶段，逐步增加 cwnd，以了解网络的可用带宽。</li>
</ul>
</li>
<li>
<p><strong>达到拥塞阈值</strong>：</p>
<ul>
<li>一旦 cwnd 达到 ssthresh，转入拥塞避免模式，通过线性增加 cwnd 继续稳定数据传输。</li>
</ul>
</li>
<li>
<p><strong>发生拥塞</strong>：</p>
<ul>
<li>当丢包被检测（如通过重传或接收到三次重复 ACK），TCP 迅速进入快速重传和快速恢复阶段。</li>
<li>cwnd 被调整，以避免进一步的丢包，并根据当前网络状况逐步恢复数据发送。</li>
</ul>
</li>
<li>
<p><strong>拥塞恢复</strong>：</p>
<ul>
<li>持续增(减)少 cwnd 以适应网络实际情况，确保流量的有效传输。</li>
</ul>
</li>
</ol>
<h3 id="拥塞控制的进步与挑战"><a class="header" href="#拥塞控制的进步与挑战">拥塞控制的进步与挑战</a></h3>
<p>进步</p>
<ul>
<li><strong>TCP Vegas</strong>：改进传统结构，基于 RTT 估算拥塞，提前进行拥塞避免。</li>
<li><strong>TCP Reno</strong>：集成了快重传与快恢复机制，有效提升了传输的灵活性与鲁棒性。</li>
<li><strong>TCP BBR</strong>：采用带宽和往返时延分析，实现观测与反馈控制，增强对动态网络环境的适应性。</li>
</ul>
<p>挑战</p>
<ul>
<li><strong>网络变化</strong>：在高度动态的网络环境中，如无线网络，拥塞控制算法需要灵活调整以适应频繁的带宽变化。</li>
<li><strong>公平性问题</strong>：多个 TCP 连接共享相同的带宽时，需要解决竞争与公平性的问题，确保没有一种连接异常占用大部分资源。</li>
</ul>
<h2 id="tcp-可靠传输"><a class="header" href="#tcp-可靠传输">TCP 可靠传输</a></h2>
<p>TCP（传输控制协议）是一种面向连接的协议，设计旨在提供可靠的数据传输服务。它确保数据从发送方到接收方的完整性、顺序性和无差错性。TCP 通过多个机制和算法实现这一目标，下面将详细介绍这些机制。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131205229.png" alt="" /></p>
<p>TCP 的可靠传输机制通过数据分段、序列号、确认应答、重传机制、校验和、流量控制及拥塞控制等多种手段，确保数据在不可靠网络上的安全、高效传输。这样的设计使得它成为互联网应用的基础，为数据的无失真、按序、按需传输提供了保证。</p>
<h3 id="可靠传输的关键机制"><a class="header" href="#可靠传输的关键机制">可靠传输的关键机制</a></h3>
<ol>
<li><strong>数据分段</strong></li>
<li><strong>序列号</strong></li>
<li><strong>确认应答</strong></li>
<li><strong>重传机制</strong></li>
<li><strong>校验和</strong></li>
<li><strong>流量控制</strong></li>
<li><strong>拥塞控制</strong></li>
</ol>
<h4 id="1-数据分段"><a class="header" href="#1-数据分段">1. 数据分段</a></h4>
<ul>
<li><strong>定义</strong>：TCP 将传输的数据流分割成适合网络传输的大小的多个数据段（segments）。</li>
<li><strong>作用</strong>：每个数据段都有自己的 TCP 头部，包含序列号和其他控制信息，便于确保每部分数据在传输中的完整性与顺序。</li>
</ul>
<h4 id="2-序列号"><a class="header" href="#2-序列号">2. 序列号</a></h4>
<ul>
<li><strong>定义</strong>：每个 TCP 数据段都包括一个序列号，唯一标识数据段的顺序。</li>
<li><strong>作用</strong>：接收方可以根据序列号重新组装数据，确保数据按正确的顺序交付给应用层。</li>
</ul>
<h4 id="3-确认应答ack"><a class="header" href="#3-确认应答ack">3. 确认应答（ACK）</a></h4>
<ul>
<li><strong>定义</strong>：接收方在成功接收到数据段后，会发送一个 ACK 包回给发送方，告知已成功接收到哪个序列号的数据。</li>
<li><strong>作用</strong>：通过确认应答机制，发送方可以了解到哪些数据段已经安全到达，进而决定是否需要重传丢失的部分。</li>
</ul>
<h4 id="4-重传机制"><a class="header" href="#4-重传机制">4. 重传机制</a></h4>
<ul>
<li><strong>定义</strong>：如果发送方在超时时间内未收到某个数据段的确认应答，它会认为该数据段在传输过程中丢失，并重传该数据段。</li>
<li><strong>快速重传</strong>：接收方会发送重复的 ACK，以指示丢失的数据段位置，发送方会立即重传丢失的部分，减少传输延迟。</li>
</ul>
<h4 id="5-校验和"><a class="header" href="#5-校验和">5. 校验和</a></h4>
<ul>
<li><strong>定义</strong>：TCP 在每个数据段中包含一个校验和字段，用于检测数据传输中可能发生的错误。</li>
<li><strong>作用</strong>：接收方在接收数据段后，会计算该数据段的校验和与头部的校验和进行比较。如果不匹配，接收方可确定该数据段存在错误，要求重传。</li>
</ul>
<h4 id="6-流量控制"><a class="header" href="#6-流量控制">6. 流量控制</a></h4>
<ul>
<li><strong>定义</strong>：TCP 使用流量控制机制（如滑动窗口）以确定发送方可发送的数据量，以防止接收方因负载过重而丢失数据。</li>
<li><strong>作用</strong>：通过动态调整窗口大小，使得接收方不会因无法及时处理数据而出现缓冲区溢出。</li>
</ul>
<h4 id="7-拥塞控制"><a class="header" href="#7-拥塞控制">7. 拥塞控制</a></h4>
<ul>
<li><strong>定义</strong>：TCP 采用拥塞控制算法（如慢启动、拥塞避免、快速重传和快速恢复）调节网络流量，以防止网络拥塞。</li>
<li><strong>作用</strong>：在网络负载过高时，控制数据的发送速率，减少数据丢失，提高网络的整体稳定性和可靠性。</li>
</ul>
<h3 id="tcp-可靠传输的工作流程"><a class="header" href="#tcp-可靠传输的工作流程">TCP 可靠传输的工作流程</a></h3>
<ol>
<li><strong>连接建立</strong>：通过三次握手（SYN, SYN-ACK, ACK）建立连接，使发送方和接收方都知道连接状态。</li>
<li><strong>数据发送</strong>：
<ul>
<li>发送方分段并发送数据。</li>
<li>每个数据段会带有序列号，并且在发送时会启动计时器监测确认应答的接收。</li>
</ul>
</li>
<li><strong>接收和确认</strong>：
<ul>
<li>接收方接收数据段并检查校验和，确认数据的完整性。</li>
<li>对成功接收到的数据段发送 ACK，告知发送方已接收的数据的序列号。</li>
</ul>
</li>
<li><strong>重传机制</strong>：
<ul>
<li>发送方监测超时情况或接收到重复 ACK 时，进行相应的数据重传。</li>
</ul>
</li>
<li><strong>连接终止</strong>：数据传输完毕后，通过四次挥手（FIN, ACK, FIN, ACK）来优雅地关闭连接，确保所有数据均已发送且确认。</li>
</ol>
<h3 id="可靠性保证的案例"><a class="header" href="#可靠性保证的案例">可靠性保证的案例</a></h3>
<ul>
<li><strong>文件传输协议（FTP）</strong>：要求文件被完整且准确地传输，通常使用 TCP 实现其可靠数据传输。</li>
<li><strong>邮件传输协议（SMTP）</strong>：发送邮件时，依赖于 TCP 确保邮件内容的完整性。</li>
</ul>
<h2 id="tcp运输连接管理连接建立和连接释放"><a class="header" href="#tcp运输连接管理连接建立和连接释放">TCP运输连接管理（连接建立和连接释放）</a></h2>
<p>TCP（传输控制协议）是一个面向连接的协议，这意味着在双方开始数据传输之前，必须首先建立一个连接。在传输结束后，必须优雅地释放这个连接。连接的建立和释放过程使用特定的机制来确保双方都完全同步。下面将详细介绍TCP的连接建立和连接释放过程。</p>
<p>TCP连接的建立和释放都是基于严格的协议规范，通过三次握手和四次挥手的过程，确保了在通信双方之间保持同步，明确连接的状态。这一机制有效防止了数据的丢失和通信的不完整，是TCP能够提供可靠传输的重要因素。</p>
<h3 id="连接建立"><a class="header" href="#连接建立">连接建立</a></h3>
<p>TCP使用**三次握手（Three-Way Handshake）**协议来建立连接。过程中，客户端和服务器之间通过交换特定的报文来确保双方都处于准备状态。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131205653.png" alt="" /></p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131211031.png" alt="" /></p>
<h4 id="三次握手的具体步骤"><a class="header" href="#三次握手的具体步骤">三次握手的具体步骤</a></h4>
<ol>
<li>
<p><strong>SYN（Synchronize）</strong></p>
<ul>
<li><strong>发起方</strong>（客户端）向<strong>目标方</strong>（服务器）发送一个SYN包，表明希望建立连接，并指定一个初始的序列号（ISN，Initial Sequence Number）。</li>
<li>这一步开始了连接的请求。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>客户端：<code>SYN, Seq = x</code></li>
</ul>
</li>
<li>
<p><strong>SYN-ACK（Synchronize-Acknowledge）</strong></p>
<ul>
<li><strong>目标方</strong>（服务器）收到SYN包后，如果同意建立连接，就会回复一个SYN-ACK包。这个包中既包含ACK确认字段，确认客户端的SYN请求（Seq = x），又包含服务器自己所选择的初始序列号（Seq = y）。</li>
<li>这一步完成了对发起连接请求的确认。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>服务器：<code>SYN-ACK, Seq = y, Ack = x+1</code></li>
</ul>
</li>
<li>
<p><strong>ACK（Acknowledge）</strong></p>
<ul>
<li><strong>发起方</strong>（客户端）收到SYN-ACK包后，发送一个ACK包，确认收到了服务器的SYN-ACK包。此ACK包的确认号（Ack）为服务器的序列号加1（Ack = y+1）。</li>
<li>这一过程结束了连接的建立。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>客户端：<code>ACK, Seq = x+1, Ack = y+1</code></li>
</ul>
</li>
</ol>
<p>完成这三次握手后，TCP连接就建立成功，双方可以开始进行数据传输。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131211015.png" alt="" /></p>
<h3 id="连接释放"><a class="header" href="#连接释放">连接释放</a></h3>
<p>TCP使用**四次挥手（Four-Way Handshake）**来释放连接，确保双方都确认停止数据传输，并正确关闭连接。</p>
<p><img src="https://cdn.jsdelivr.net/gh/Rosefinch-Midsummer/MyImagesHost04/img20250131211112.png" alt="" /></p>
<h4 id="四次挥手的具体步骤"><a class="header" href="#四次挥手的具体步骤">四次挥手的具体步骤</a></h4>
<ol>
<li>
<p><strong>FIN（Finish）</strong></p>
<ul>
<li>某一方（假设为发起方）决定关闭连接，它会向另一方（目标方）发送一个FIN包，表示希望终止数据传输。此FIN包带有一个序列号。</li>
<li>这表明发起方没有更多数据要发送。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>发起方：<code>FIN, Seq = a</code></li>
</ul>
</li>
<li>
<p><strong>ACK（Acknowledge）</strong></p>
<ul>
<li>目标方收到FIN包后，发送一个ACK包，确认发起方的请求。此ACK包的确认号（Ack）为发起方的序列号加1（Ack = a+1）。此时，目标方可以继续接收数据，直到它准备好关闭连接。</li>
<li>这一步标志着目标方已经同意关闭连接，但仍然可以发送数据。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>目标方：<code>ACK, Seq = b, Ack = a+1</code></li>
</ul>
</li>
<li>
<p><strong>FIN</strong></p>
<ul>
<li>目标方在完成数据发送后，向发起方发送一个FIN包，表示它也没有更多数据要发送，并请求关闭连接。</li>
<li>目标方同样会选择一个序列号。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>目标方：<code>FIN, Seq = c</code></li>
</ul>
</li>
<li>
<p><strong>ACK（Acknowledge）</strong></p>
<ul>
<li>发起方接收到目标方的FIN包，发送一个ACK包作为确认。该ACK包的确认号（Ack）为目标方的序列号加1（Ack = c+1）。</li>
<li>此时，发起方完成了对连接的释放过程。</li>
</ul>
<p><strong>示例</strong>：</p>
<ul>
<li>发起方：<code>ACK, Seq = a+1, Ack = c+1</code></li>
</ul>
</li>
</ol>
<p>在此四次挥手之后，TCP连接被成功释放。此时，两方资源均可重新分配以供其他连接使用。</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="网络层.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="应用层.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="网络层.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="应用层.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>


        <script src="elasticlunr.min.js"></script>
        <script src="mark.min.js"></script>
        <script src="searcher.js"></script>

        <script src="clipboard.min.js"></script>
        <script src="highlight.js"></script>
        <script src="book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
